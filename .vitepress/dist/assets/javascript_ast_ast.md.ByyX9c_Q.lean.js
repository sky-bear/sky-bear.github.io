/* empty css                                                                     */import{c as a,a2 as s,o as l}from"./chunks/framework.BAVNBlau.js";const p=JSON.parse('{"title":"前段 AST","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/ast/ast.md","filePath":"javascript/ast/ast.md"}'),t={name:"javascript/ast/ast.md"},k=Object.assign(t,{setup(e){return(n,i)=>(l(),a("div",null,i[0]||(i[0]=[s(`<h1 id="前段-ast" tabindex="-1">前段 AST <a class="header-anchor" href="#前段-ast" aria-label="Permalink to &quot;前段 AST&quot;">​</a></h1><h2 id="ast-介绍" tabindex="-1">AST 介绍 <a class="header-anchor" href="#ast-介绍" aria-label="Permalink to &quot;AST 介绍&quot;">​</a></h2><p>抽象语法书 AST ,AST 是一种树形结构，用来表示源代码的抽象语法结构。每个节点代表源代码中的一个结构，这使得它成为编译过程中的一个重要工具</p><h2 id="编译器" tabindex="-1">编译器 <a class="header-anchor" href="#编译器" aria-label="Permalink to &quot;编译器&quot;">​</a></h2><p>compiler 也叫编译器，是一种电脑程序，它会将用某种编程语言写成的源代码，转换成另一种编程语言。<br>简单来说就是高级语言转换成低级语言 编译器就是个将当前语言转为其他语言的过程，回到 babel 上，它所做的事就是语法糖之类的转换，比如 ES6/ES7/JSX 转为 ES5 或者其他指定版本，因此称之为 compiler 也是正确的，换言之，像我们平时开发过程中所谓的其他工具，如：</p><ul><li>Less/Saas</li><li>TypeScript/coffeeScript</li><li>Eslint</li><li>etc... 都可以看到 compiler 的身影，也是通过这些工具，才使得目前的前端工程化能走入相对的深水区</li></ul><h2 id="编译器的转换思路" tabindex="-1">编译器的转换思路 <a class="header-anchor" href="#编译器的转换思路" aria-label="Permalink to &quot;编译器的转换思路&quot;">​</a></h2><h3 id="词法分析" tabindex="-1">词法分析 <a class="header-anchor" href="#词法分析" aria-label="Permalink to &quot;词法分析&quot;">​</a></h3><p>词法分析（Lexical Analysis）是编译过程中的第一个阶段，其主要任务是从源代码中识别出尽可能多的最小有意义单元，这些单元被称为记号（tokens）。记号可以包括关键字、操作符、标识符、常量、注释等。词法分析器（也称为扫描器或 lexer）读取源程序的字符流，并将其转换成记号流，供语法分析阶段使用</p><ul><li>目的 将文本分割成一个个的“token”，例如：init、main、init、x、;、x、=、3、;、}等等。同时它可以去掉一些注释、空格、回车等等无效字符；</li><li>生成方式，词法分析有两种方式 <ul><li>正则表达式：[vue2，vue3]的模版解析 需要写大量的正则表达式，正则之间还有冲突需要处理，不容易维护，性能不高，所以正则只适合一些简单的模板语法，真正复杂的语言并不合适。并且有的语言并不一定自带正则引擎</li><li>自动机 基于有限自动机（Finite Automata）的原理设计词法分析器。通常会使用确定性有限自动机（DFA）或者非确定性有限自动机（NFA）来实现。从理论上讲，这种方法能够高效地处理大量的输入数据</li></ul></li></ul><h3 id="语法分析" tabindex="-1">语法分析 <a class="header-anchor" href="#语法分析" aria-label="Permalink to &quot;语法分析&quot;">​</a></h3><p>语法分析（Syntactic Analysis）是编译过程中的一个重要阶段，它紧跟在词法分析之后。在这一阶段，词法分析器生成的记号流将被解析成一个抽象语法树（AST），以确定源代码是否符合语言的语法规则。如果源代码不符合语法规则，语法分析器将会产生错误信息 &lt;br / &gt; 典型应用如 babel 插件，它的原理就是：es6 代码 → Babylon.parse → AST → babel-traverse → 新的 AST → es5 代码。</p><ul><li>目的 <ul><li>验证语法正确性：检查输入的程序是否遵循编程语言定义的语法规则</li><li>构建抽象语法树（AST） 为后续的编译阶段提供结构化的表示形式，便于进行语义分析、优化和代码生成。</li></ul></li><li>方法 <ul><li>自顶向下</li><li>自底向上</li></ul></li></ul><h3 id="代码转换" tabindex="-1">代码转换 <a class="header-anchor" href="#代码转换" aria-label="Permalink to &quot;代码转换&quot;">​</a></h3><p>在得到 AST 后，我们一般会先将 AST 转为另一种 AST，目的是生成更符合预期的 AST，这一步称为代码转换。</p><p>代码转换的优势：主要是产生工程上的意义</p><ul><li>易移植：与机器无关，所以它作为中间语言可以为生成多种不同型号的目标机器码服务；</li><li>机器无关优化：对中间码进行机器无关优化，利于提高代码质量；</li><li>层次清晰：将 AST 映射成中间代码表示，再映射成目标代码的工作分层进行，使编译算法更加清晰 ；</li></ul><p>对于一个 Compiler 而言，在转换阶段通常有两种形式： 同语言的 AST 转换； AST 转换为新语言的 AST； 这里有一种通用的做法是，对我们之前的 AST 从上至下的解析（称为 traversal），然后会有个映射表（称为 visitor），把对应的类型做相应的转换。</p><h3 id="代码生成-code-generation" tabindex="-1">代码生成 (Code Generation) <a class="header-anchor" href="#代码生成-code-generation" aria-label="Permalink to &quot;代码生成 (Code Generation)&quot;">​</a></h3><p>在实际的代码处理过程中，可能会递归的分析我们最终生成的 AST，然后对于每种 type 都有个对应的函数处理，当然，这可能是最简单的做法。总之，我们的目标代码会在这一步输出，对于我们的目标语言，它就是 HTML 了。</p><h3 id="完整链路-compiler" tabindex="-1">完整链路(Compiler) <a class="header-anchor" href="#完整链路-compiler" aria-label="Permalink to &quot;完整链路(Compiler)&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tokenizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tokens; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 词法分析</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tokens</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ast; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 语法分析，生成AST</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">transformer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newAst; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 中间层代码转换</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newAst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">generator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> output; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成目标代码</span></span></code></pre></div><h2 id="ast-的使用" tabindex="-1">ast 的使用 <a class="header-anchor" href="#ast-的使用" aria-label="Permalink to &quot;ast 的使用&quot;">​</a></h2><p>用途</p><ul><li>转译 esnext、typescript 等到目标环境支持的 js</li><li>代码的静态检查 <ul><li>linter 工具、也是基于 AST，对代码检查</li></ul></li></ul><p>从 babel7 开始，所有的官方插件和主要模块，都放在了 @babel 的命名空间下。从而可以避免在 npm 仓库中 babel 相关名称被抢注的问题，并且采用了 Babel Monorepo 风格的仓库。</p><ul><li>@babel/parser: 接受源码，进行词法分析、语法分析，生成 AST。</li><li>@babel/traverse：接受一个 AST，并对其遍历，根据 preset、plugin 进行逻辑处理，进行替换、删除、添加节点。</li><li>@babel/generator：接受最终生成的 AST，并将其转换为代码字符串，同时此过程也可以创建 source map。</li><li>@babel/types：用于检验、构建和改变 AST 树的节点</li><li>@babel/core: Babel 的编译器，核心 API 都在这里面，比如常见的 transform、parse，并实现了插件功能</li></ul><h2 id="相关网站" tabindex="-1">相关网站 <a class="header-anchor" href="#相关网站" aria-label="Permalink to &quot;相关网站&quot;">​</a></h2><p><a href="https://astexplorer.net/" target="_blank" style="display:block;">AST </a><a href="https://nwy3y7fy8w5.feishu.cn/docx/Fn7xdVZJKopjEexYYCucTn0znub" target="_blank" style="display:block;">前端 AST </a></p>`,29)])))}});export{p as __pageData,k as default};
